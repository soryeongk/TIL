# Next.js pre-rendering SSR vs SSG 후기

0809의 기록에 나와있듯이 Next.js에서 렌더링 방식의 차이가 속도면에서 무엇이 다른지를 비교해보았습니다.

SSG가 빠르다는 사실을 밝혀낼 수 있었습니다.

## 결과: 속도 차이

|     | requests | transferred | resources |  Finish   | DOMContentLoaded |   Load    |
| :-: | :------: | :---------: | :-------: | :-------: | :--------------: | :-------: |
| 😞 SSR |    49    |    6.7kB    |   1.9MB   | **5.37s** |    **196ms**     | **235ms** |
| :sparkles: SSG |    48    |    6.2kB    |   1.9MB   | **5.26s** |     **85ms**     | **130ms** |

## 그럼에도 불구하고..

**하지만 최종으로 채택된 방식은 SSR입니다.**

SSG는 속도면에서 우수하다는 장점이 있지만, 빌드타임에 생성된 뷰를 재활용한다는 것은 **정보 전달의 측면에서 치명적**입니다.

업데이트가 거의 없는 페이지이고, 업데이트가 있더라도 관리자가 컨트롤할 수 있는 페이지인 것은 사실입니다.

이 측면에서만 바라보면 상품의 상세 페이지를 SSG로 작성하는 것은 꽤 매력적입니다.

하지만, 이 페이지는 개인 블로그가 아닌 상품을 판매하는 페이지로 **"가격" 정보에 대한 민감도가 매우 높습니다.**

예를 들어, 업데이트로 인해 상품의 가격이 모두 변경되었는데, 일부 사용자가 아직 업데이트되기 전의 화면을 보고 있다가 결제를 하는 경우를 가정해봅시다.

사용자가 업데이트 이전의 화면을 보고 있던 중에 업데이트가 발생할 수도 있고, 캐시된 페이지의 화면을 보고 있을 수도 있습니다.

사용자는 분명 1만원이라고 생각하고 결제 화면에 들어왔는데, 그 사이 업데이트로 인해 결제 화면에서는 2만원이라고 나올 수도 있고,

혹은 화면에는 1만원이라고 표시되지만 서버 상에는 2만원으로 기록되어있어 결제 오류가 발생할 수도 있습니다.

관리자가 업데이트마다 철저하게 관리한다고 해도 사람은 실수할 수 있다는 대 전제를 무시할 수 없고,

이런 크리티컬한 문제가 발생할 가능성이 있고, 그 문제로 인한 부정적인 상황의 정도가 심각하다면,

**SSG가 아무리 빠르더라도 채택할 수 없게 되는 것입니다..**

그렇게 령이의 삽질 종료..
